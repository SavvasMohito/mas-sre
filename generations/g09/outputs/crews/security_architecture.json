{
  "raw": "### 9.1. Architectural Security Principles\n\nArchitectural security principles provide the foundational philosophy guiding all security design decisions. These principles ensure a consistent security posture across all system components and guide selection and implementation of controls so the Shift Management System remains resilient, auditable, and privacy-preserving.\n\n- **Zero Trust Architecture principles:** Never trust, always verify \u2014 every request, user, and service must be authenticated and authorized regardless of network location; reduces risk from compromised internal networks and enforces fine-grained controls.\n- **Defense in Depth:** Deploy multiple layers (network, host, application, data) so that failure of one control does not result in a total compromise; ensures redundancy and detection opportunities at each layer.\n- **Principle of Least Privilege:** Grant users, services, and processes only the minimum permissions required to perform tasks; reduces blast radius of compromised accounts or services.\n- **Secure by Default / Secure by Design:** Systems are secure out-of-the-box with safe defaults (secure configs, disabled debug endpoints), and security is incorporated throughout the SDLC and architecture.\n- **Separation of Duties:** Split responsibilities across roles and systems (e.g., admin vs. operator vs. auditor) to limit fraud and mistakes and to provide checks-and-balances for sensitive actions like accepting solver results or exporting data.\n- **Fail Secure:** In failure scenarios default to safe-deny behaviors (e.g., reject unverified solver responses, deny access on auth service failures) to prevent unauthorized operations.\n- **Complete Mediation:** Every access to a resource is checked against up-to-date authorization policy (no caching of authorization decisions without revalidation for sensitive operations).\n- **Minimize Attack Surface:** Reduce exposed interfaces and services; disable unnecessary features, and limit public endpoints to those required for the SPA/API gateway.\n- **Auditability and Accountability:** Design to capture immutable audit trails for security-relevant events (authentication, acceptance of auto-assignment, exports, leave records) with sufficient context for investigations and compliance.\n- **Data Minimization and Privacy-by-Design:** Collect and store the minimum personal data necessary; treat leave and preference data as potentially sensitive and apply stronger protections and PIAs.\n- **Cryptographic Best-Practices:** Use modern, vetted algorithms, centralized key management, short-lived credentials where possible, and hardware-backed keys (HSM/KMS) for critical secrets.\n- **Resilience and Observability:** Instrument system health, security telemetry, and business events to detect misuse and faults quickly and support IR and SLA goals.\n\n---\n\n### 9.2. Component-Level Security Controls\n\n#### Frontend User Interface\n\n**Required Controls:**\n\n- Enforce output encoding and input validation on all user-supplied content.\n- Implement Content Security Policy (CSP), X-Frame-Options, X-Content-Type-Options, and Referrer-Policy headers.\n- Use OAuth2/OpenID Connect Authorization Code flow with PKCE for Google sign-in.\n- Use secure, HttpOnly, SameSite=strict cookies or short-lived access tokens stored in secure browser cookie with CSRF protections.\n- Implement CSRF protection for all state-changing requests.\n- Validate and canonicalize locale-specific inputs to defend against injection/XSS through localization.\n- Prevent sensitive data in localStorage; avoid persisting tokens to client side beyond short-lived needs.\n- Implement client-side rate-limiting UI protections (to reduce accidental high frequency) and enforce rate limits server-side.\n- Protect file downloads (exports) with signed, time-limited pre-signed URLs and role checks.\n\n**Recommended Patterns:**\n\n- Serve SPA via CDN with SRI (subresource integrity) and strict TLS enforcement.\n- WAF in front of static assets to block known web attacks and bot abuse.\n- Use same-origin policies and secure cookie settings; prefer cookie-based session with anti-CSRF tokens for forms.\n- Use client-side feature flags with server-side guard for risky features (auto-accept of solver results disabled by default for lower roles).\n- Implement localization libraries that sanitize and canonicalize input/output.\n\n#### Edge Layer (CDN & API Gateway)\n\n**Required Controls:**\n\n- TLS termination with TLS1.3 preferred and strong cipher suite; enforce HSTS.\n- Web Application Firewall (managed rules + custom rules) with OWASP top-10 protections enabled.\n- DDoS protection and rate limiting per IP and per API key/tenant.\n- API authentication and token validation at gateway (JWT stateless validation and introspection for opaque tokens).\n- Geo/IP-based access controls and egress/ingress filtering for management endpoints.\n- Request size limits and schema validation at gateway for large solver/payload submissions.\n- Centralized access logging (structured logs), WAF alerts, and request tracing headers (correlation id).\n\n**Recommended Patterns:**\n\n- API Gateway with OAuth2 token validation and JWT introspection and per-tenant quota enforcement.\n- Use a layered edge model: CDN for static assets + WAF + API Gateway for dynamic endpoints.\n- mTLS between API gateway and backend application services for internal trust.\n- Gateway-level response caching for safe-read endpoints and circuit-breaker patterns for external service unavailability.\n\n#### Application Services\n\n**Required Controls:**\n\n- Centralized Authentication and Authorization service (AuthN/AuthZ) with RBAC + ABAC support; evaluate Open Policy Agent (OPA) for policy enforcement.\n- Strong password handling: Argon2id (or bcrypt with modern params) with per-user salts; enforce password policy and rate-limit login and reset attempts.\n- Multi-factor authentication (MFA) option for admins and managers.\n- Role and tenant scoping enforced server-side on every API (complete mediation).\n- Input validation and canonicalization for business objects (shifts, times, preference data) and solver payloads.\n- Audit events for all security-relevant operations (user CRUD, exports, accept/reject solver solution, status changes) with before/after state.\n- Service-to-service authentication using short-lived tokens and mTLS; secrets stored in KMS/secret manager and rotated automatically.\n- Background job authorization and validation for queued tasks and solver orchestration; jobs signed and verified.\n- Strict schema validation and whitelisting for Timefold solver responses; do not auto-commit without operator validation.\n- Protect endpoints with rate limiting, anomaly detection (excessive changes), and IP reputation checks.\n\n**Recommended Patterns:**\n\n- Microservices architecture with an API Gateway fronting services and a centralized auth service.\n- Policy engine (OPA) or centralized IAM for RBAC/ABAC decisions integrated into middleware.\n- Service mesh (e.g., Istio) for mTLS, traffic control, observability, and failure isolation between services.\n- Use message queue (SQS/RabbitMQ) with encrypted payloads and ACLs for async jobs.\n- Use signed job payloads and integrity checks (HMAC/JWS) for async job lifecycle.\n\n#### Data Layer\n\n**Required Controls:**\n\n- Row-level tenant isolation (tenant_id predicate enforced at data layer) or per-tenant schema architecture to prevent cross-tenant access.\n- Database encryption at rest (TDE) and field-level/envelope encryption for highly sensitive fields (leave reasons, medical data).\n- Strong DB authentication with IAM/managed identities; no long-lived DB credentials in code.\n- Backups encrypted, access-controlled, and tested for restoration; backup retention policy aligned to compliance.\n- Database activity monitoring and audit logs capturing DML operations for sensitive tables.\n- Prepared statements / ORM parameterization and input validation to prevent SQL injection.\n- Redis/session cache encrypted in transit and at rest; strict ACLs for caches.\n\n**Recommended Patterns:**\n\n- Managed RDBMS with Transparent Data Encryption + column-level encryption for PII.\n- Use Row-Level Security (RLS) or mandatory tenant filter middleware to enforce tenant scoping.\n- VPC-only database access; private subnets and restricted admin bastion with MFA.\n- Object storage with server-side encryption + customer-managed keys for exported artifacts and solver artifacts.\n\n#### External Services\n\n**Required Controls:**\n\n- Explicit trust model and contractual SLAs/security requirements for each supplier (Google OAuth, Email provider, Timefold).\n- Use secure connection models (OAuth2/OpenID Connect with ID token validation; mTLS for solver where supported).\n- Secrets for external APIs stored and rotated via KMS/secret manager; restrict scopes to least privilege.\n- End-to-end logging and correlation for requests/responses to/from external services; validate all external responses.\n- Circuit breakers and retry/backoff policies for external service failures.\n\n**Recommended Patterns:**\n\n- Private connectivity (VPC endpoints, PrivateLink) to external providers where supported to avoid public internet egress.\n- Use signed payloads (JWS) or message-level integrity checks for solver payloads/results.\n- Centralized integration gateway for third-party calls with per-integration policies (rate limit, auth, monitoring).\n\n---\n\n### 9.3. Data Protection Strategy\n\n**Data Classification:** Public, Internal, Confidential, Restricted\n\n- Public: Non-sensitive static content (marketing copy, CSS, JavaScript) that can be publicly accessible.\n- Internal: Operational metadata and logs that are not user-identifiable (system metrics, anonymized analytics).\n- Confidential: User profile data, job metadata, shift assignments (excluding sensitive leave reasons), company records, skills, shift types.\n- Restricted: Sensitive personal data (leave reasons containing health info, explicit PII like national identifiers), solver payloads that include PII tied to optimization decisions, audit trails containing sensitive context, and exports including PII.\n\n**Encryption Requirements:**\n\n- Data in transit: TLS 1.3 preferred; support TLS 1.2 with strong ciphers (ECDHE with AES-GCM or ChaCha20-Poly1305). Enforce HSTS and disable insecure ciphers and legacy protocols.\n- Data at rest:\n  - Use AES-256-GCM for symmetric encryption of databases, object storage, and backups.\n  - Use envelope encryption with customer-managed keys (CMKs) stored/managed in KMS/HSM.\n  - Field-level encryption for Restricted fields using AES-256-GCM with keys derived via KMS and, where necessary, additional application-level encryption.\n- Keys and signatures:\n  - Use RSA-3072 or ECDSA P-256/P-384 for asymmetric needs; prefer ECC (P-256 or secp384r1) for signatures (e.g., JWS ES256/ES384).\n  - Password hashing: Argon2id with tuned parameters (memory, iterations) appropriate to platform; store only salted hashes.\n  - HMAC: Use HMAC-SHA256 or better for integrity checks.\n- Solver interactions:\n  - Use mTLS where supported, or OAuth2 Client Credentials with short-lived tokens.\n  - Consider payload signing (JWS) so solver responses can be verified against known public keys.\n\n**Retention Policies:**\n\n- User account data: Retain active account data while account status is ACTIVE; upon deletion/requested erasure, remove or anonymize within 30 days unless legal hold applies.\n- Preferences and unavailable dates: Retain for business needs; default retention 2 years unless user requests deletion or longer retention required by employer policies.\n- Solver artifacts and generated assignments: Keep drafts and solver payloads for 90 days by default for audit/traceability; mark older artifacts for purge or archive to long-term cold storage if needed for compliance (7 years if required by contracts).\n- Export files: Keep pre-signed export artifacts available for download for 7 days then auto-delete. If a copy is retained server-side (for audit), store in encrypted object storage with limited retention (90 days) unless flagged for longer retention with approval.\n- Audit logs: Maintain security and audit logs for at least 1 year online and archive for up to 7 years depending on regulatory requirements.\n- Backups: Encrypted backups retained per organizational recovery objectives (e.g., 30-90 days rotation, archived snapshots per legal requirements).\n\n**Handling Procedures:**\n\n- Access:\n  - Enforce role-based and attribute-based access controls; require approval/workflow for exports containing Confidential/Restricted data.\n  - Sensitive fields (Restricted) accessible only to authorized roles and logged with justification.\n- Transmission:\n  - All external communications use TLS; prefer private connectivity to external providers.\n  - For solver payloads, enforce payload signing or HMAC and validate integrity on receipt.\n- Storage:\n  - Apply least-privilege IAM for data stores and KMS; restrict access to key usage via IAM policies.\n  - Implement monitoring and alerting for anomalous accesses (large exports, bulk reads).\n- Deletion:\n  - Implement soft-delete with secure permanent deletion policy: soft-delete retention for recoverability (e.g., 30 days) then cryptographic shredding (delete keys and data) or secure wipe per storage provider capabilities.\n  - For GDPR/CCPA erasure requests: remove personal identifiers and replace with pseudonymous token; purge all backups subject to legal hold exceptions and document actions.\n- Backups and replication:\n  - Ensure backups are encrypted and keys rotated; test restore processes.\n- Export sanitization:\n  - Redact or pseudonymize sensitive fields in exports by default; create role-based templates for sensitive exports requiring approval and additional logging.\n- Developer and CI/CD:\n  - Secrets never in source control. Use ephemeral credentials in CI/CD, secrets manager integration, SCA checks on dependencies, and signing of build artifacts.\n\n---\n\n### 9.4. Third-Party Integration Security\n\n**Google OAuth (OpenID Connect)**\n\n*Security Requirements:*\n\n- Use OAuth2/OpenID Connect Authorization Code flow with PKCE.\n- Validate ID tokens server-side (aud, iss, exp, nonce).\n- Restrict redirect URIs to exact values and register app secrets in secrets manager.\n- Scopes limited to minimum required identity attributes.\n\n*Risk Assessment:* High \u2014 identity provider compromise or misconfiguration can allow account takeovers or impersonation. Incorrect token validation can yield privilege escalation.\n\n*Recommended Controls:*\n\n- Use well-vetted OIDC libraries and perform server-side token validation.\n- Enforce client secrets and redirect URI restrictions; rotate client secrets periodically.\n- Map federated identities to internal accounts with tenant-binding checks and do not grant elevated roles without additional verification (e.g., email domain checks and admin approval).\n- Monitor OAuth events, anomalous sign-ins, and adopt adaptive risk-based controls (MFA for suspicious sessions).\n\n**Email Delivery Provider (e.g., SendGrid, SES, Mailgun)**\n\n*Security Requirements:*\n\n- Use API keys stored in secrets manager with least privilege.\n- Enforce TLS for SMTP/API endpoints.\n- Sign transactional emails via DKIM and SPF configuration for domain.\n\n*Risk Assessment:* Medium \u2014 email is used for verification and password resets; compromise or interception can enable account takeover.\n\n*Recommended Controls:*\n\n- Rotate API keys and restrict inbound/outbound domains.\n- Rate-limit email sends and monitor for abnormal volumes (spam detection).\n- Use signed verification links (single-use, short-lived tokens) and monitor bounce/failure rates.\n\n**Timefold Optimization Solver**\n\n*Security Requirements:*\n\n- mTLS or OAuth2 client credentials for mutual authentication.\n- Schema validation for solver payloads and responses.\n- Signed payloads or HMAC to establish integrity/trust between system and solver.\n\n*Risk Assessment:* High \u2014 solver results directly affect schedule and may contain PII; corrupted or malicious responses could create unsafe assignments or data leakage.\n\n*Recommended Controls:*\n\n- Use mTLS or mutually authenticated TLS endpoints; restrict endpoints and IPs via allowlists.\n- Sign requests (JWS) and require signed responses; validate signatures before allowing preview or commit.\n- Sandbox parsing and extensive schema validation; treat solver as untrusted until validated.\n- Keep solver payloads and responses encrypted in transit and at rest; log inputs/outputs for audit with redaction for sensitive fields.\n\n**CDN & WAF Provider**\n\n*Security Requirements:*\n\n- TLS termination with HTTP security headers support.\n- Access to management console restricted with MFA and RBAC.\n- Support for custom WAF rules and real-time logging.\n\n*Risk Assessment:* High \u2014 misconfiguration or provider compromise may expose traffic or bypass protections.\n\n*Recommended Controls:*\n\n- Use least-privileged API keys, restrict management IPs, and enforce MFA for admin management.\n- Deploy custom WAF rulesets for app patterns and tune with observable logs.\n- Integrate CDN logs into SOC pipeline for monitoring and incident response.\n\n**Object Storage (S3-compatible)**\n\n*Security Requirements:*\n\n- Server-side encryption with CMKs and enforce TLS for all transfers.\n- Bucket policies limiting public access and enforcing VPC endpoints where possible.\n\n*Risk Assessment:* High \u2014 exported artifacts and solver artifacts stored here may contain PII; misconfigured buckets lead to data exposure.\n\n*Recommended Controls:*\n\n- Block public access by default; use pre-signed URLs for downloads and short TTLs.\n- Enforce bucket-level logging and object lock/WORM for audit archives as appropriate.\n- Use lifecycle policies to auto-delete artifacts per retention rules.\n\n**Queueing/Background Job System (SQS, RabbitMQ)**\n\n*Security Requirements:*\n\n- TLS for broker connections; access control lists for producers/consumers.\n- Message-level encryption and integrity checks for solver payloads.\n\n*Risk Assessment:* Medium \u2014 job tampering or unauthorized enqueuing could trigger unauthorized operations or leak data.\n\n*Recommended Controls:*\n\n- Enforce authentication for producers/consumers and validate job payloads before processing.\n- Use signed job tokens and schema validation; audit enqueue/dequeue events.\n\n**Monitoring & Logging (Datadog/CloudWatch or SIEM)**\n\n*Security Requirements:*\n\n- Secure ingestion endpoints, role-based access to dashboards, and encrypted storage for logs.\n- Integration must not leak PII to public dashboards.\n\n*Risk Assessment:* Medium \u2014 logs contain sensitive info; exposure could expose PII or secrets.\n\n*Recommended Controls:*\n\n- Redact or mask PII in logs prior to ingestion; use separate role-based dashboards for sensitive telemetry.\n- Protect alerting channels with MFA and integrate monitoring alerts into incident response workflows.\n\n**HR/External Identity or Directory Sync (if integrated later)**\n\n*Security Requirements:*\n\n- Use SCIM or secure API with OAuth2; consent and least-privilege provisioning.\n- Implement reconciliation and mutual authentication.\n\n*Risk Assessment:* High \u2014 provisioning errors can result in privilege escalation or orphaned accounts.\n\n*Recommended Controls:*\n\n- Keep provisioning scope minimal, audit provisioning events, and provide manual approval steps for sensitive role assignments.\n\n---\n\nOverall Integration and Orchestration Notes\n\n- All integrations must be captured in a supplier security profile (SLA, incident response expectations, audit rights).\n- Use encryption-in-flight and at-rest consistently; prefer private network connectivity (VPC, PrivateLink) where supported.\n- Log correlation IDs end-to-end for tracing solver jobs from submission through solution commit or rejection.\n- Implement automated smoke tests and contract tests for integrations; include negative tests (malformed payloads, replayed responses).\n- Maintain a supplier risk register and conduct periodic security reviews and penetration tests involving third-parties.\n\n---\n\nAppendix \u2014 Operational and Governance Recommendations (concise)\n\n- CI/CD: Sign build artifacts, enforce SCA and dependency scanning, require PR code reviews, and gate deployments with security checks.\n- Secrets Management: Centralize secrets in KMS/secret manager with automated rotation and narrow IAM roles.\n- Incident Response: Playbooks for compromised solver responses, mass export detection, or data exfiltration; tabletop exercises twice yearly.\n- Privacy & Compliance: Conduct PIAs for preference and leave modules; document legal basis for data processing and support DSAR/erasure workflows.\n- Testing: Include fuzzing for solver parser, localization-based XSS test cases, RBAC pentesting, and multi-tenant isolation testing.\n- Personnel: Least-privilege admin accounts, break glass procedures with audit and short TTL, enforce MFA, and periodic access reviews.\n- Operational Monitoring: SIEM rules for unusual export volumes, mass changes in shifts, repeated failed auth attempts, and anomalous solver acceptances.\n\nThis document, when applied across engineering, platform, and security ops, provides a coherent, defense-in-depth architecture that enables secure handling of sensitive employee scheduling data, trustworthy integration with external solvers, and auditable operations suitable for a multi-tenant cloud-hosted Shift Management System.",
  "tasks": [
    {
      "name": "design_security_architecture",
      "raw": "### 9.1. Architectural Security Principles\n\nArchitectural security principles provide the foundational philosophy guiding all security design decisions. These principles ensure a consistent security posture across all system components and guide selection and implementation of controls so the Shift Management System remains resilient, auditable, and privacy-preserving.\n\n- **Zero Trust Architecture principles:** Never trust, always verify \u2014 every request, user, and service must be authenticated and authorized regardless of network location; reduces risk from compromised internal networks and enforces fine-grained controls.\n- **Defense in Depth:** Deploy multiple layers (network, host, application, data) so that failure of one control does not result in a total compromise; ensures redundancy and detection opportunities at each layer.\n- **Principle of Least Privilege:** Grant users, services, and processes only the minimum permissions required to perform tasks; reduces blast radius of compromised accounts or services.\n- **Secure by Default / Secure by Design:** Systems are secure out-of-the-box with safe defaults (secure configs, disabled debug endpoints), and security is incorporated throughout the SDLC and architecture.\n- **Separation of Duties:** Split responsibilities across roles and systems (e.g., admin vs. operator vs. auditor) to limit fraud and mistakes and to provide checks-and-balances for sensitive actions like accepting solver results or exporting data.\n- **Fail Secure:** In failure scenarios default to safe-deny behaviors (e.g., reject unverified solver responses, deny access on auth service failures) to prevent unauthorized operations.\n- **Complete Mediation:** Every access to a resource is checked against up-to-date authorization policy (no caching of authorization decisions without revalidation for sensitive operations).\n- **Minimize Attack Surface:** Reduce exposed interfaces and services; disable unnecessary features, and limit public endpoints to those required for the SPA/API gateway.\n- **Auditability and Accountability:** Design to capture immutable audit trails for security-relevant events (authentication, acceptance of auto-assignment, exports, leave records) with sufficient context for investigations and compliance.\n- **Data Minimization and Privacy-by-Design:** Collect and store the minimum personal data necessary; treat leave and preference data as potentially sensitive and apply stronger protections and PIAs.\n- **Cryptographic Best-Practices:** Use modern, vetted algorithms, centralized key management, short-lived credentials where possible, and hardware-backed keys (HSM/KMS) for critical secrets.\n- **Resilience and Observability:** Instrument system health, security telemetry, and business events to detect misuse and faults quickly and support IR and SLA goals.\n\n---\n\n### 9.2. Component-Level Security Controls\n\n#### Frontend User Interface\n\n**Required Controls:**\n\n- Enforce output encoding and input validation on all user-supplied content.\n- Implement Content Security Policy (CSP), X-Frame-Options, X-Content-Type-Options, and Referrer-Policy headers.\n- Use OAuth2/OpenID Connect Authorization Code flow with PKCE for Google sign-in.\n- Use secure, HttpOnly, SameSite=strict cookies or short-lived access tokens stored in secure browser cookie with CSRF protections.\n- Implement CSRF protection for all state-changing requests.\n- Validate and canonicalize locale-specific inputs to defend against injection/XSS through localization.\n- Prevent sensitive data in localStorage; avoid persisting tokens to client side beyond short-lived needs.\n- Implement client-side rate-limiting UI protections (to reduce accidental high frequency) and enforce rate limits server-side.\n- Protect file downloads (exports) with signed, time-limited pre-signed URLs and role checks.\n\n**Recommended Patterns:**\n\n- Serve SPA via CDN with SRI (subresource integrity) and strict TLS enforcement.\n- WAF in front of static assets to block known web attacks and bot abuse.\n- Use same-origin policies and secure cookie settings; prefer cookie-based session with anti-CSRF tokens for forms.\n- Use client-side feature flags with server-side guard for risky features (auto-accept of solver results disabled by default for lower roles).\n- Implement localization libraries that sanitize and canonicalize input/output.\n\n#### Edge Layer (CDN & API Gateway)\n\n**Required Controls:**\n\n- TLS termination with TLS1.3 preferred and strong cipher suite; enforce HSTS.\n- Web Application Firewall (managed rules + custom rules) with OWASP top-10 protections enabled.\n- DDoS protection and rate limiting per IP and per API key/tenant.\n- API authentication and token validation at gateway (JWT stateless validation and introspection for opaque tokens).\n- Geo/IP-based access controls and egress/ingress filtering for management endpoints.\n- Request size limits and schema validation at gateway for large solver/payload submissions.\n- Centralized access logging (structured logs), WAF alerts, and request tracing headers (correlation id).\n\n**Recommended Patterns:**\n\n- API Gateway with OAuth2 token validation and JWT introspection and per-tenant quota enforcement.\n- Use a layered edge model: CDN for static assets + WAF + API Gateway for dynamic endpoints.\n- mTLS between API gateway and backend application services for internal trust.\n- Gateway-level response caching for safe-read endpoints and circuit-breaker patterns for external service unavailability.\n\n#### Application Services\n\n**Required Controls:**\n\n- Centralized Authentication and Authorization service (AuthN/AuthZ) with RBAC + ABAC support; evaluate Open Policy Agent (OPA) for policy enforcement.\n- Strong password handling: Argon2id (or bcrypt with modern params) with per-user salts; enforce password policy and rate-limit login and reset attempts.\n- Multi-factor authentication (MFA) option for admins and managers.\n- Role and tenant scoping enforced server-side on every API (complete mediation).\n- Input validation and canonicalization for business objects (shifts, times, preference data) and solver payloads.\n- Audit events for all security-relevant operations (user CRUD, exports, accept/reject solver solution, status changes) with before/after state.\n- Service-to-service authentication using short-lived tokens and mTLS; secrets stored in KMS/secret manager and rotated automatically.\n- Background job authorization and validation for queued tasks and solver orchestration; jobs signed and verified.\n- Strict schema validation and whitelisting for Timefold solver responses; do not auto-commit without operator validation.\n- Protect endpoints with rate limiting, anomaly detection (excessive changes), and IP reputation checks.\n\n**Recommended Patterns:**\n\n- Microservices architecture with an API Gateway fronting services and a centralized auth service.\n- Policy engine (OPA) or centralized IAM for RBAC/ABAC decisions integrated into middleware.\n- Service mesh (e.g., Istio) for mTLS, traffic control, observability, and failure isolation between services.\n- Use message queue (SQS/RabbitMQ) with encrypted payloads and ACLs for async jobs.\n- Use signed job payloads and integrity checks (HMAC/JWS) for async job lifecycle.\n\n#### Data Layer\n\n**Required Controls:**\n\n- Row-level tenant isolation (tenant_id predicate enforced at data layer) or per-tenant schema architecture to prevent cross-tenant access.\n- Database encryption at rest (TDE) and field-level/envelope encryption for highly sensitive fields (leave reasons, medical data).\n- Strong DB authentication with IAM/managed identities; no long-lived DB credentials in code.\n- Backups encrypted, access-controlled, and tested for restoration; backup retention policy aligned to compliance.\n- Database activity monitoring and audit logs capturing DML operations for sensitive tables.\n- Prepared statements / ORM parameterization and input validation to prevent SQL injection.\n- Redis/session cache encrypted in transit and at rest; strict ACLs for caches.\n\n**Recommended Patterns:**\n\n- Managed RDBMS with Transparent Data Encryption + column-level encryption for PII.\n- Use Row-Level Security (RLS) or mandatory tenant filter middleware to enforce tenant scoping.\n- VPC-only database access; private subnets and restricted admin bastion with MFA.\n- Object storage with server-side encryption + customer-managed keys for exported artifacts and solver artifacts.\n\n#### External Services\n\n**Required Controls:**\n\n- Explicit trust model and contractual SLAs/security requirements for each supplier (Google OAuth, Email provider, Timefold).\n- Use secure connection models (OAuth2/OpenID Connect with ID token validation; mTLS for solver where supported).\n- Secrets for external APIs stored and rotated via KMS/secret manager; restrict scopes to least privilege.\n- End-to-end logging and correlation for requests/responses to/from external services; validate all external responses.\n- Circuit breakers and retry/backoff policies for external service failures.\n\n**Recommended Patterns:**\n\n- Private connectivity (VPC endpoints, PrivateLink) to external providers where supported to avoid public internet egress.\n- Use signed payloads (JWS) or message-level integrity checks for solver payloads/results.\n- Centralized integration gateway for third-party calls with per-integration policies (rate limit, auth, monitoring).\n\n---\n\n### 9.3. Data Protection Strategy\n\n**Data Classification:** Public, Internal, Confidential, Restricted\n\n- Public: Non-sensitive static content (marketing copy, CSS, JavaScript) that can be publicly accessible.\n- Internal: Operational metadata and logs that are not user-identifiable (system metrics, anonymized analytics).\n- Confidential: User profile data, job metadata, shift assignments (excluding sensitive leave reasons), company records, skills, shift types.\n- Restricted: Sensitive personal data (leave reasons containing health info, explicit PII like national identifiers), solver payloads that include PII tied to optimization decisions, audit trails containing sensitive context, and exports including PII.\n\n**Encryption Requirements:**\n\n- Data in transit: TLS 1.3 preferred; support TLS 1.2 with strong ciphers (ECDHE with AES-GCM or ChaCha20-Poly1305). Enforce HSTS and disable insecure ciphers and legacy protocols.\n- Data at rest:\n  - Use AES-256-GCM for symmetric encryption of databases, object storage, and backups.\n  - Use envelope encryption with customer-managed keys (CMKs) stored/managed in KMS/HSM.\n  - Field-level encryption for Restricted fields using AES-256-GCM with keys derived via KMS and, where necessary, additional application-level encryption.\n- Keys and signatures:\n  - Use RSA-3072 or ECDSA P-256/P-384 for asymmetric needs; prefer ECC (P-256 or secp384r1) for signatures (e.g., JWS ES256/ES384).\n  - Password hashing: Argon2id with tuned parameters (memory, iterations) appropriate to platform; store only salted hashes.\n  - HMAC: Use HMAC-SHA256 or better for integrity checks.\n- Solver interactions:\n  - Use mTLS where supported, or OAuth2 Client Credentials with short-lived tokens.\n  - Consider payload signing (JWS) so solver responses can be verified against known public keys.\n\n**Retention Policies:**\n\n- User account data: Retain active account data while account status is ACTIVE; upon deletion/requested erasure, remove or anonymize within 30 days unless legal hold applies.\n- Preferences and unavailable dates: Retain for business needs; default retention 2 years unless user requests deletion or longer retention required by employer policies.\n- Solver artifacts and generated assignments: Keep drafts and solver payloads for 90 days by default for audit/traceability; mark older artifacts for purge or archive to long-term cold storage if needed for compliance (7 years if required by contracts).\n- Export files: Keep pre-signed export artifacts available for download for 7 days then auto-delete. If a copy is retained server-side (for audit), store in encrypted object storage with limited retention (90 days) unless flagged for longer retention with approval.\n- Audit logs: Maintain security and audit logs for at least 1 year online and archive for up to 7 years depending on regulatory requirements.\n- Backups: Encrypted backups retained per organizational recovery objectives (e.g., 30-90 days rotation, archived snapshots per legal requirements).\n\n**Handling Procedures:**\n\n- Access:\n  - Enforce role-based and attribute-based access controls; require approval/workflow for exports containing Confidential/Restricted data.\n  - Sensitive fields (Restricted) accessible only to authorized roles and logged with justification.\n- Transmission:\n  - All external communications use TLS; prefer private connectivity to external providers.\n  - For solver payloads, enforce payload signing or HMAC and validate integrity on receipt.\n- Storage:\n  - Apply least-privilege IAM for data stores and KMS; restrict access to key usage via IAM policies.\n  - Implement monitoring and alerting for anomalous accesses (large exports, bulk reads).\n- Deletion:\n  - Implement soft-delete with secure permanent deletion policy: soft-delete retention for recoverability (e.g., 30 days) then cryptographic shredding (delete keys and data) or secure wipe per storage provider capabilities.\n  - For GDPR/CCPA erasure requests: remove personal identifiers and replace with pseudonymous token; purge all backups subject to legal hold exceptions and document actions.\n- Backups and replication:\n  - Ensure backups are encrypted and keys rotated; test restore processes.\n- Export sanitization:\n  - Redact or pseudonymize sensitive fields in exports by default; create role-based templates for sensitive exports requiring approval and additional logging.\n- Developer and CI/CD:\n  - Secrets never in source control. Use ephemeral credentials in CI/CD, secrets manager integration, SCA checks on dependencies, and signing of build artifacts.\n\n---\n\n### 9.4. Third-Party Integration Security\n\n**Google OAuth (OpenID Connect)**\n\n*Security Requirements:*\n\n- Use OAuth2/OpenID Connect Authorization Code flow with PKCE.\n- Validate ID tokens server-side (aud, iss, exp, nonce).\n- Restrict redirect URIs to exact values and register app secrets in secrets manager.\n- Scopes limited to minimum required identity attributes.\n\n*Risk Assessment:* High \u2014 identity provider compromise or misconfiguration can allow account takeovers or impersonation. Incorrect token validation can yield privilege escalation.\n\n*Recommended Controls:*\n\n- Use well-vetted OIDC libraries and perform server-side token validation.\n- Enforce client secrets and redirect URI restrictions; rotate client secrets periodically.\n- Map federated identities to internal accounts with tenant-binding checks and do not grant elevated roles without additional verification (e.g., email domain checks and admin approval).\n- Monitor OAuth events, anomalous sign-ins, and adopt adaptive risk-based controls (MFA for suspicious sessions).\n\n**Email Delivery Provider (e.g., SendGrid, SES, Mailgun)**\n\n*Security Requirements:*\n\n- Use API keys stored in secrets manager with least privilege.\n- Enforce TLS for SMTP/API endpoints.\n- Sign transactional emails via DKIM and SPF configuration for domain.\n\n*Risk Assessment:* Medium \u2014 email is used for verification and password resets; compromise or interception can enable account takeover.\n\n*Recommended Controls:*\n\n- Rotate API keys and restrict inbound/outbound domains.\n- Rate-limit email sends and monitor for abnormal volumes (spam detection).\n- Use signed verification links (single-use, short-lived tokens) and monitor bounce/failure rates.\n\n**Timefold Optimization Solver**\n\n*Security Requirements:*\n\n- mTLS or OAuth2 client credentials for mutual authentication.\n- Schema validation for solver payloads and responses.\n- Signed payloads or HMAC to establish integrity/trust between system and solver.\n\n*Risk Assessment:* High \u2014 solver results directly affect schedule and may contain PII; corrupted or malicious responses could create unsafe assignments or data leakage.\n\n*Recommended Controls:*\n\n- Use mTLS or mutually authenticated TLS endpoints; restrict endpoints and IPs via allowlists.\n- Sign requests (JWS) and require signed responses; validate signatures before allowing preview or commit.\n- Sandbox parsing and extensive schema validation; treat solver as untrusted until validated.\n- Keep solver payloads and responses encrypted in transit and at rest; log inputs/outputs for audit with redaction for sensitive fields.\n\n**CDN & WAF Provider**\n\n*Security Requirements:*\n\n- TLS termination with HTTP security headers support.\n- Access to management console restricted with MFA and RBAC.\n- Support for custom WAF rules and real-time logging.\n\n*Risk Assessment:* High \u2014 misconfiguration or provider compromise may expose traffic or bypass protections.\n\n*Recommended Controls:*\n\n- Use least-privileged API keys, restrict management IPs, and enforce MFA for admin management.\n- Deploy custom WAF rulesets for app patterns and tune with observable logs.\n- Integrate CDN logs into SOC pipeline for monitoring and incident response.\n\n**Object Storage (S3-compatible)**\n\n*Security Requirements:*\n\n- Server-side encryption with CMKs and enforce TLS for all transfers.\n- Bucket policies limiting public access and enforcing VPC endpoints where possible.\n\n*Risk Assessment:* High \u2014 exported artifacts and solver artifacts stored here may contain PII; misconfigured buckets lead to data exposure.\n\n*Recommended Controls:*\n\n- Block public access by default; use pre-signed URLs for downloads and short TTLs.\n- Enforce bucket-level logging and object lock/WORM for audit archives as appropriate.\n- Use lifecycle policies to auto-delete artifacts per retention rules.\n\n**Queueing/Background Job System (SQS, RabbitMQ)**\n\n*Security Requirements:*\n\n- TLS for broker connections; access control lists for producers/consumers.\n- Message-level encryption and integrity checks for solver payloads.\n\n*Risk Assessment:* Medium \u2014 job tampering or unauthorized enqueuing could trigger unauthorized operations or leak data.\n\n*Recommended Controls:*\n\n- Enforce authentication for producers/consumers and validate job payloads before processing.\n- Use signed job tokens and schema validation; audit enqueue/dequeue events.\n\n**Monitoring & Logging (Datadog/CloudWatch or SIEM)**\n\n*Security Requirements:*\n\n- Secure ingestion endpoints, role-based access to dashboards, and encrypted storage for logs.\n- Integration must not leak PII to public dashboards.\n\n*Risk Assessment:* Medium \u2014 logs contain sensitive info; exposure could expose PII or secrets.\n\n*Recommended Controls:*\n\n- Redact or mask PII in logs prior to ingestion; use separate role-based dashboards for sensitive telemetry.\n- Protect alerting channels with MFA and integrate monitoring alerts into incident response workflows.\n\n**HR/External Identity or Directory Sync (if integrated later)**\n\n*Security Requirements:*\n\n- Use SCIM or secure API with OAuth2; consent and least-privilege provisioning.\n- Implement reconciliation and mutual authentication.\n\n*Risk Assessment:* High \u2014 provisioning errors can result in privilege escalation or orphaned accounts.\n\n*Recommended Controls:*\n\n- Keep provisioning scope minimal, audit provisioning events, and provide manual approval steps for sensitive role assignments.\n\n---\n\nOverall Integration and Orchestration Notes\n\n- All integrations must be captured in a supplier security profile (SLA, incident response expectations, audit rights).\n- Use encryption-in-flight and at-rest consistently; prefer private network connectivity (VPC, PrivateLink) where supported.\n- Log correlation IDs end-to-end for tracing solver jobs from submission through solution commit or rejection.\n- Implement automated smoke tests and contract tests for integrations; include negative tests (malformed payloads, replayed responses).\n- Maintain a supplier risk register and conduct periodic security reviews and penetration tests involving third-parties.\n\n---\n\nAppendix \u2014 Operational and Governance Recommendations (concise)\n\n- CI/CD: Sign build artifacts, enforce SCA and dependency scanning, require PR code reviews, and gate deployments with security checks.\n- Secrets Management: Centralize secrets in KMS/secret manager with automated rotation and narrow IAM roles.\n- Incident Response: Playbooks for compromised solver responses, mass export detection, or data exfiltration; tabletop exercises twice yearly.\n- Privacy & Compliance: Conduct PIAs for preference and leave modules; document legal basis for data processing and support DSAR/erasure workflows.\n- Testing: Include fuzzing for solver parser, localization-based XSS test cases, RBAC pentesting, and multi-tenant isolation testing.\n- Personnel: Least-privilege admin accounts, break glass procedures with audit and short TTL, enforce MFA, and periodic access reviews.\n- Operational Monitoring: SIEM rules for unusual export volumes, mass changes in shifts, repeated failed auth attempts, and anomalous solver acceptances.\n\nThis document, when applied across engineering, platform, and security ops, provides a coherent, defense-in-depth architecture that enables secure handling of sensitive employee scheduling data, trustworthy integration with external solvers, and auditable operations suitable for a multi-tenant cloud-hosted Shift Management System."
    }
  ]
}